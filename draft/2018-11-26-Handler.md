---
layout:     post
title:      Handler源码解析
subtitle:    ""
date:       2018-11-26
author:     guoqing
header-img: img/posts/06.jpg
catalog: true
tags:
    - Android
    - Android Framwork
---
***
 ***源码基于Android8.0.0***
***
### 目录
> 1.Handler介绍   
> 2.Handler使用方法  
> 3.Handler源码分析
### Handler介绍
&nbsp;&nbsp;&nbsp;&nbsp;Handler是Android中的消息机制的实现，作用主要是切换任务到不同线程中执行。由于Android系统子线程不能访问UI线程的限制，如下代码所示。
```java
//from ViewRootImpl.java
void checkThread() {
     if (mThread != Thread.currentThread()) {
         throw new CalledFromWrongThreadException(
                 "Only the original thread that created a view hierarchy can touch its views.");
     }
 }
```
所以工作线程是不能直接访问UI线程的。但如果在UI线程执行耗时任务，会导致ANR。因此Handler的一个用处是将耗时任务在子线程中执行，通过Handler将结果从工作线程发送到UI线程，从而达到更新UI界面的目的。
### Handler使用方法
Handler是消息机制的上层接口，开发者只需要和Handler打交道。Handler的主要用途：
- 消息创建
- 向消息队列里插入消息
- 在目标线程处理消息
- 消息管理  
Handler构造方法  
```java
//1.使用默认Looper
new Handler();
new Handler(Handler.Callback);
//2.自定义Looper  
new Handler(Looper);
new Handler(Looper, Handler.Callback);
```
消息创建
```java
Message obtainMessage(int what, int arg1, int arg2)
Message obtainMessage()
Message obtainMessage(int what, int arg1, int arg2, Object obj)
Message obtainMessage(int what)
Message obtainMessage(int what, Object obj)
```
消息队列插入消息  
Handler插入消息有两种方式，一种是Post一个Runnable，第二种是sendMessage
```java
//1. 向MessageQueue里插入一个Task
boolean post(Runnable r)
boolean postAtFrontOfQueue(Runnable r)
boolean postAtTime(Runnable r, Object token, long uptimeMillis)
boolean postAtTime(Runnable r, long uptimeMillis)
boolean postDelayed(Runnable r, long delayMillis)
//2. 向MessageQueue插入一个data
boolean sendMessage(Message msg)
boolean sendMessageAtFrontOfQueue(Message msg)
boolean sendMessageAtTime(Message msg, long uptimeMillis)
boolean sendMessageDelayed(Message msg, long delayMillis)
```
处理消息  
消息有两种类型，一种是runnable类型的task，一种是data，两种方式的处理方法如下：
```java
//1. task
handler.post(new Runnable() {
   @Override
   public void run() {
       //TODO : Do some operation
   }
});
//2. data
final Handler handler = new Handler() {
     @Override
     public void handleMessage(Message message) {
        //TODO : Get the data from Message and perform opertation accordingly.
     }
 };
```
消息管理  
Handler可以将消息从消息队列中移除
```java
removeCallbacks(Runnable r)
removeCallbacks(Runnable r, Object token)
removeMessages(int what)
removeMessages(int what, Object object)
removeCallbacksAndMessages(Object token)
```
### Handler源码解析
***消息机制的真正实现已经被移到Native层，这里只分析Java framework层源码***  
消息机制主要由Handler、Looper、MessageQueue三部分组成。Handler一旦初始化完毕，就可以向MessageQueue里发送消息，Handler中的Looper一旦检测到MessageQueue里有消息，就会处理这个消息。下面具体分析每部分的工作原理。  
  - MessageQueue  
  消息队列是由单链表来实现的（由于链表在插入删除时效率较高），主要有两个操作enqueueMessage和next分别对应向链表里插入一条消息和取出一条消息。下面具体看看两个方法的实现。  
  ```java
  //from MessageQueue.java
  boolean enqueueMessage(Message msg, long when) {

       synchronized (this) {
           if (mQuitting) {
               IllegalStateException e = new IllegalStateException(
                       msg.target + " sending message to a Handler on a dead thread");
               Log.w(TAG, e.getMessage(), e);
               msg.recycle();
               return false;
           }

           msg.markInUse();
           msg.when = when;
           Message p = mMessages;
           boolean needWake;
           if (p == null || when == 0 || when < p.when) {
               // New head, wake up the event queue if blocked.
               msg.next = p;
               mMessages = msg;
               needWake = mBlocked;
           } else {
               // Inserted within the middle of the queue.  Usually we don't have to wake
               // up the event queue unless there is a barrier at the head of the queue
               // and the message is the earliest asynchronous message in the queue.
               needWake = mBlocked && p.target == null && msg.isAsynchronous();
               Message prev;
               for (;;) {
                   prev = p;
                   p = p.next;
                   if (p == null || when < p.when) {
                       break;
                   }
                   if (needWake && p.isAsynchronous()) {
                       needWake = false;
                   }
               }
               msg.next = p; // invariant: p == prev.next
               prev.next = msg;
           }

           // We can assume mPtr != 0 because mQuitting is false.
           if (needWake) {
               nativeWake(mPtr);
           }
       }
       return true;
   }
  ```
  可以看出enqueueMessage只是执行的单链表的插入操作，下面来看next方法。
  ```java
  Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
  ```
  可以看出next是个无限循环方法，如果msg为空循环一直阻塞，如果消息不为null则从队列中删除这条消息并将消息返回。
  - Looper
  - Handler  
 Handler主要负责消息的收发及管理工作，具体方法已在Handler使用方法中介绍。下面看一下send或post的具体实现。
 ```Java
 // from Handler.Java
 public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }

    public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis < 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
 ```
可以看出sendMessage经过sendMessage->sendMessageDelayed->sendMessageAtTime->enqueueMessage最终只是将message插入到消息队列
