---
layout:     post
title:      Activity启动流程
subtitle:    ""
date:       2019-03-14
author:     guoqing
header-img: img/posts/06.jpg
catalog: true
tags:
    - Android
    - Android Framwork
---
### Activity启动流程源码分析
Activity是Android四大组件之一，Activity的启动过程对了解Android系统的原理有很大的帮助。下面从源码开始分析Activity的启动过程。
首先从Activity的startActivity开始。
```java
@Override
   public void startActivity(Intent intent, @Nullable Bundle options) {
       if (options != null) {
           startActivityForResult(intent, -1, options);
       } else {
           // Note we want to go through this call for compatibility with
           // applications that may have overridden the method.
           startActivityForResult(intent, -1);
       }
   }

```
可以看到调用的是startActivityForResult方法，如下：
```java
public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
           @Nullable Bundle options) {
       if (mParent == null) {
           options = transferSpringboardActivityOptions(options);
           Instrumentation.ActivityResult ar =
               mInstrumentation.execStartActivity(
                   this, mMainThread.getApplicationThread(), mToken, this,
                   intent, requestCode, options);
          ....
       } else {
           ....
       }
   }

```
```java
 private IBinder mToken;
 ActivityThread mMainThread;
 public ApplicationThread getApplicationThread()
  {
      return mAppThread;
  }
```
可以看出里面主要是调用Instrumentation的execStartActivity方法,其中mToken为IBinder类型，mMainThread为ActivityThread类型,getApplicationThread方法为ApplicationThread。继续看execStartActivity方法。
```java
public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, String target,
        Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i<N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    ActivityResult result = null;
                    if (am.ignoreMatchingSpecificIntents()) {
                        result = am.onStartActivity(intent);
                    }
                    if (result != null) {
                        am.mHits++;
                        return result;
                    } else if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return requestCode >= 0 ? am.getResult() : null;
                        }
                        break;
                    }
                }
            }
        }
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target, requestCode, 0, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }
```
可以看出真正启动Activity的方法为ActivityManager.getService()
    .startActivity，getService方法的如下：
    ```java
    public static IActivityManager getService() {
       return IActivityManagerSingleton.get();
   }

   private static final Singleton<IActivityManager> IActivityManagerSingleton =
           new Singleton<IActivityManager>() {
               @Override
               protected IActivityManager create() {
                   final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                   final IActivityManager am = IActivityManager.Stub.asInterface(b);
                   return am;
               }
           };
    ```
get()方法返回的是IActivityManager，而搜索Android8.0源码发现IActivityManager是个AIDL文件，因此Activity的启动过程是个跨进程通信
