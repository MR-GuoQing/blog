---
layout:     post
title:      OkHttp源码解析
subtitle:    ""
date:       2019-3-7
author:     guoqing
header-img: img/posts/06.jpg
catalog: true
tags:
    - Android
    - Third party library
---

### Okhttp源码解析

#### 1、OKhttp使用流程
```java
OkHttpClient client = new OkHttpClient();
Request request = new Request().Builder().get().url(url).build();
client.newCall(request).execute();
```
首先初始化OkHttpClient，新建Request，OkHttpClient和request都是采用构建者模式，可以通过Builder()来添加、配置相关的参数，可以。通过client 的newCall方法将request封装成一个call对象（Call代表了一个准备执行的请求），然后调用call的同步execute()或异步enqueue()方法发送请求。
#### 2、OkHttp发送请求的流程
首先分析call的异步请求，call是个接口，从它的实现类RealCall的enqueue()方法开始。
```java
@Override public void enqueue(Callback responseCallback) {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already Executed");
      executed = true;
    }
    captureCallStackTrace();
    eventListener.callStart(this);
    client.dispatcher().enqueue(new AsyncCall(responseCallback));
  }

````
enqueue方法会调用dispatcher的enqueue方法（dispatch后面分析），dispatch的enqueue主要是将callback加入它的异步队列中，而callback是被封装成AsyncCall的。AsyncCall是继承自NamedRunnable, NamedRunnable继承自Runnable接口，所以AsyncCall是一个线程。
```java
public abstract class NamedRunnable implements Runnable {
...
  @Override public final void run() {
  ...
      execute();
  ...
  }
  protected abstract void execute();
}
```
因此主要逻辑在AsyncCall的execute方法中：
```java
//from AsyncCall.java
@Override protected void execute() {
      boolean signalledCallback = false;
      timeout.enter();
      try {
        Response response = getResponseWithInterceptorChain();
        if (retryAndFollowUpInterceptor.isCanceled()) {
          signalledCallback = true;
          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
        } else {
          signalledCallback = true;
          responseCallback.onResponse(RealCall.this, response);
        }
      } catch (IOException e) {
        e = timeoutExit(e);
        if (signalledCallback) {
          // Do not signal the callback twice!
          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
        } else {
          eventListener.callFailed(RealCall.this, e);
          responseCallback.onFailure(RealCall.this, e);
        }
      } finally {
        client.dispatcher().finished(this);
      }
    }
```
可以看到主要是调用getResponseInterceptorChain()方法，然后将response的结果放入callback中。
```java
//from RealCall.java
Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List<Interceptor> interceptors = new ArrayList<>();
    interceptors.addAll(client.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());
    }
    interceptors.add(new CallServerInterceptor(forWebSocket));

    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
        originalRequest, this, eventListener, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());

    return chain.proceed(originalRequest);
  }
}
```
getResponseInterceptorChain()方法是处理拦截器，依次将 client.interceptors()(用户自定义的拦截器)、retryandFollowUpInterceptors(重试及重定向)、BrigeInterceptor、CachInterceptor、ConnectInterceptor、CallServerInterceptor添加到List中实现不同的功能。然后新建一个RealInterceptorChain，并调用其proceed方法，以使各个interceptor顺序执行。Interceptor的实现使用的是责任链模式，下面具体分析RealInterceptorChain。
#### 3、InterceptorChain
```java
Private final List<Interceptor>interceptors;   // 拦截器容器
Private final StreamAllocation streamAllocation;//流管理器
Private final HttpCodec httpCodec;//http 流
Private final RealConnection connection;//Socket链接
Private final int index;//Interceptor 当前索引
Private final Request request;//请求
Private int calls;//proceed 方法执行的次数
```
RealInterceptorChain继承自Chain接口，成员变量StreamAllocation、HttpCodec、RealConnection用于Socket链接，主要是proceed方法
```java
public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
      RealConnection connection) throws IOException {
    if (index >= interceptors.size()) throw new AssertionError();

    calls++;

    // If we already have a stream, confirm that the incoming request will use it.
    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
          + " must retain the same host and port");
    }
    // If we already have a stream, confirm that this is the only call to chain.proceed().
    if (this.httpCodec != null && calls > 1) {
      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
          + " must call proceed() exactly once");
    }

    // Call the next interceptor in the chain.
    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
        writeTimeout);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);

    // Confirm that the next interceptor made its required call to chain.proceed().
    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
      throw new IllegalStateException("network interceptor " + interceptor
          + " must call proceed() exactly once");
    }

    // Confirm that the intercepted response isn't null.
    if (response == null) {
      throw new NullPointerException("interceptor " + interceptor + " returned null");
    }

    if (response.body() == null) {
      throw new IllegalStateException(
          "interceptor " + interceptor + " returned a response with no body");
    }

    return response;
  }
```
前面一大段代码都是域名、端口等信息检查，然后会新建一个RealInterceptorChain用于下一个interceptor的调用，通过index+1来确保每次调用proceed方法是使用的是不同的interceptor，最后调用拦截器的intercept方法。下图是retryandfollowupinterceptor拦截器的intercept方法。

可以看出拦截器会调用chain 的proceed方法，并把request传递到下一个拦截器中，确保每个interceptor被执行。
4、Dispatcher

Dispathcer主要用来异步请求中线程的管理策略，dispatcher的成员变量如图所示，maxRequest代表最大的并发请求数64，maxRequestPerHost每个主机的最大连接数位5个，executorService线程池，readyAsyncCalls等待执行的异步队列，runningAsyncCalls正在执行的异步队列，runningSyncCalls正在执行的同步队列.
